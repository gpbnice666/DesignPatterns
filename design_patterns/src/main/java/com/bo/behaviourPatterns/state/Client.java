package com.bo.behaviourPatterns.state;

/**
 * @author gpb
 */
public class Client {
    public static void main(String[] args) {
        Context context = new Context();
        context.Handle();
        context.Handle();
        context.Handle();
        context.Handle();
    }
}
/**
 *
 * 在软件开发中,应用程序中的部分对象可能会根据不同的情况做出不同的行为,我们把这种对象成为有状态对象
 * 而把影响对象行为的一个或多个变化的属性成为状态
 * 当有状态的对象与外部事件产生互动时,其内部就h会发生改变,
 * 比如人都有高兴和伤心的时候，不同的情绪有不同的行为,当然外界也会影响情绪变化
 *
 * 对这种有状态的对象编程,传统的解决方案：将这些所以可能发生的情况全都考虑到,然后使用 if else 或者 switch case 语句来进行判断，在
 * 进行不同情况下的处理 但是显然这种方法对复杂的状态判断存在天然弊端，条件判读语句会过于臃肿，可读性差，且不具扩展行，维护难度大
 * 且增加新的状态要 添加 if else  不利于程序的扩展
 *
 * 以上问题如果采用“状态模式”就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，
 * 把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，
 * 这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。
 *
 * 状态模式定义：
 *          对有状态的对象，把复杂的判断逻辑 提取到不同的状态对象中，允许状态对象在其内部状态改变时改变其行为
 * 优点
 *       结构清晰,状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态分割出来,满足 单一职责
 *       将状态转换成显示化,减少对象间的互相依赖,将不同的状态引入独立的对象中会使得状态转换变得更加明确,且减少对象间的的相互依赖
 *       状态类职责明确,有利于程序的扩展 通过定义新的子类很容易的增加新的状态和转换
 * 缺点
 *      状态模式的应用使用必然会增加系统的类与对象的个数
 *      状态模式的结构与实现都较为复杂，如果使用不当会导致恒旭结构和代码混乱
 *      状态模式对开闭原则支持的并不太好，对于可以切换状态的模式，增加新的状态类需要修改那些负责状态转换的源码。否则
 *      无法切换到新增状态，而且修改某个状态的行为也需要修改对相应的源码
 *
 * 结构和 实现
 *          状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在内部状态改变的时候，其行为也随之改变，
 *  结构：
 *      环境类：也成为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责状态的切换
 *      抽象状态类：定义个接口或抽象类，用于封装环境对象中的特定状态所对应的行为，可以有一个或多个
 *      具体状态：实现抽象状态所对应的行为并且在选哟的情况下进行状态切换和
 *
 *
 */
