package com.bo.behaviourPatterns.templateMethod;

import com.bo.behaviourPatterns.templateMethod.impl.Ferrari812;
import com.bo.behaviourPatterns.templateMethod.impl.Ferrari911;

/**
 * @author gpb
 * 模板方法模式：
 *          定义一个操作中的算法骨架,而将算法的一些步骤延迟到子类中,是的子类可以不改变算法的结构的情况下
 *          重定义该算法的特定步骤,一种行为模式
 * 优点
 *         他封装了不变部分,扩展可变的部分,他把认为是不变部分的算法封装到父类中实现,而把可变部分算法，有子类继承实现,便于子类继续扩展
 *         他在父类中提取了公共的部分代码,便于代码服用
 *         部分方法是由子类实现的,因此子类可以通过扩展方式增加相应的功能,符合开闭原则
 *
 * 缺点
 *        对每个不同的实现都需要定义一个子类,这会导致类的个数增加,系统更加庞大,设计也更加的抽象,间接的增加了系统实现的复杂都
 *        父类中抽象方法由子类实现,子类执行的结果会影响父类的结果,这导致一种反向的控制结构,提高了代码的难度
 *        由于继承关系自身的缺点,如果父类添加抽象方法,则所以的子类都要改一遍
 *  结构
 *      模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。
 *      现在来介绍它们的基本结构。
 *  角色
 *      1）抽象类/抽象模板（Abstract Class）
 *        抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。
 *
 *         ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
 *
 *         ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。
 *       抽象方法：在抽象类中声明，由具体子类实现。
 *       具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
 *       钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。
 *      2）具体子类/具体实现（Concrete Class）
 *     具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤
 *
 */

public class Client {
    public static void main(String[] args) {
        CarModel ferrari812 = new Ferrari812();
        ferrari812.run();
        System.out.println("--------------------------");
        CarModel ferrari911 = new Ferrari911();
        ferrari911.run();
    }
}
