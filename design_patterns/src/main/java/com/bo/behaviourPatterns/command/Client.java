package com.bo.behaviourPatterns.command;

import com.bo.behaviourPatterns.command.commandImpl.ConcreteCommand;

/**
 * @author gpb
 * 客户端
 */
public class Client {

    public static void main(String[] args) {
        ConcreteCommand concreteCommand = new ConcreteCommand();
        Invoker invoker = new Invoker(concreteCommand);
        System.out.println("客户端访问调用者call()方法。。。");
       invoker.call();
    }

}
/*
* 在软件开发系统中，“方法的请求者”与“方法的实现者”之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。
* 例如，想对方法进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与实现者解耦？”变得很重要，命令模式就能很好地解决这个问题。
*
* 在现实生活中,命令模式得例子也很多。比如看电视时。我们只需要轻轻一安遥控器就能完成频道得切换，这就是命令模式
* 将换台请求，和换台处理完全解耦了，电视剧遥控器（命令发送者）通过按钮（具体命令） 遥控电视机（命令结束者）
*
* 定义
*      将一个请求封装为一个对象，使发出请求得责任和执行请求得责任分割开，这杨两者之间通过命令对象进行沟通，者杨方便将命令对象
*      进行存储、传递、调用、增加与管理
* 优点：
*       通过引入中间件(抽象接口)降低系统得耦合都
*       扩展性良好，增加或删除命令非常方便，采用命令模式增加与删除命令不会迎影响其他类
*       可以实现宏命令，命令模式可以与组合模式结合。将多个命令装配成一个组合命令，即宏命令
*       方便实现Undo和Redo操作，命令模式可以与备忘录模式结合，实现命令得撤销和恢复
*       可以在现有得命令基础上，增加额外功能，比如日志记录，结合装饰模式会更加灵活
* 缺点：
*       可能产生大量具体得命令类。以为每一个具体操作都需要设计一个具体命令类，;
*       命令模式得结果其实就是接受方得执行结果，但是为了以命令得形式进行架构、解耦请求与实现、引入了额外类型结构
*       （引入了请求方与抽象命令接口），增加了理解上得困难，不过者也是设计模式得通病，抽象必然会额外增加类得数量
*       代码聚合更加难理解
*
* 结构
*       抽象命令类角色(Command): 声明执行命令得接口，拥有执行命令得抽象方法
*       具体命令类角色(Concrete Command): 是抽象命令得具体实现类，他拥有接受对象，并通过调用接收者得功能老完成命令要执行得操作
*       实现者\接受者（Receiver） 执行命令功能相关得操作，是具体命令对象业务得真正实现者
*       调用者\请求者(Invoker) 是请求得发送者，它通常拥有很多得命令对象，并通过访问命令对象来执行相关得请求，他不直接访问接收者
*
*
*
*
*
*
*
*
*
*
*
*
* */
